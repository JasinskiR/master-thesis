%Porównanie Rust i C++
\chapter{Wnioski oraz rekomendacje}
Przeprowadzone badanie ujawniło fundamentalne ograniczenie narzędzia hwloc-ps na platformie macOS, szczególnie w architekturze Apple Silicon, wynikające z celowych restrykcji systemowych w jądrze XNU. Jak wykazano w \cite{HWLOC555}, brak implementacji interfejsów sched\_setaffinity()/sched\_getaffinity() uniemożliwia odczyt i kontrolę przypisań procesów do rdzeni (process-to-core binding), co stanowi istotną barierę metodologiczną w porównawczych badaniach wydajnościowych między architekturami ARM (M1) i x86\_64. W odróżnieniu od pełnej funkcjonalności hwloc-ps w systemie Linux \cite{hwlocHardwareLocality}, gdzie narzędzie precyzyjnie raportuje przypisania wątków, na macOS możliwe jest jedynie wykrywanie topologii sprzętowej przez lstopo - przy użyciu mechanizmów sysctl. Ograniczenie to, uniemożliwiło bezpośrednią weryfikację wpływu przypisań wątków (thread pinning) na wydajność implementacji współbieżnych w językach Rust/C++.

W trakcie prac nad implementacją aplikacji w języku C++ z wykorzystaniem biblioteki Threading Building Blocks (TBB) zaobserwowano istotne różnice w procesie budowania i konfiguracji projektu pomiędzy platformami opartymi na architekturze x86-64 (Linux) a systemem macOS z procesorem Apple M1 (ARM64). Jest to również potwierdzone przez pracę \cite{ARMTBB}. Aplikacja, która kompilowała się bezproblemowo i działała optymalnie w środowisku x86, wymagała licznych modyfikacji przy próbie przeniesienia jej na platformę Apple Silicon. W szczególności konieczne było ręczne dostosowanie flag kompilatora, aktualizacja konfiguracji CMake z uwzględnieniem architektury ARM oraz zastosowanie społecznościowych łatek w celu rozwiązania problemów z rozpoznawaniem architektury („Unknown architecture flag: -arch armv4t”). Te trudności potwierdzają, że proces przenoszenia aplikacji opartych na TBB na macOS z procesorem M1 nie jest trywialny i wymaga świadomego podejścia projektowego oraz głębszego zrozumienia różnic międzyplatformowych — zarówno na poziomie sprzętowym, jak i systemowym. Dodatkowo są też prace, które pokazują, że testy na maszynie wirtualnej z emulacją Intel wykazały spadek wydajności w porównaniu z natywnym wykonaniem na M1 \cite{TBBARMCONCLUSIONS}.

Klasa std::jthread została wprowadzona dopiero w standardzie C++20, który nie jest w pełni wspierany przez kompilator Apple Clang w wersji 15.0.0. Ograniczenia te należy uwzględnić przy tworzeniu aplikacji na system macOS, co wymusza zastosowanie alternatywnych rozwiązań programistycznych zapewniających kompatybilność z daną wersją kompilatora. Analiza wyników działania CMake wskazuje, że nawet przy użyciu kompilatora Clang w wersji 20.1.6, klasa std::jthread pozostaje niedostępna. Wynika to z faktu, iż jej obsługa zależy nie tylko od samego kompilatora, lecz również od implementacji biblioteki standardowej C++. W środowisku macOS, mimo wykorzystania najnowszej wersji Clanga, systemowa wersja biblioteki libc++ może nie zawierać jeszcze implementacji std::jthread. W związku z tym pełna zgodność ze standardem C++20 w zakresie zarządzania wątkami wymaga nie tylko odpowiedniego kompilatora, ale także aktualnej wersji biblioteki standardowej.



The option of developing new computer languages may be the clean- est and most efficient way to provide support for parallel processing. However, practical issues make the wide acceptance of a new computer language close to impossible. Nobody likes to rewrite old code to new lan- guages. It is difficult to justify such effort in most cases. Also, educating and convincing a large enough group of developers to make a new lan- guage gain critical mass is an extremely difficult task.