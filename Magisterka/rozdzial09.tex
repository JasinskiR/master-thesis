%Porównanie Rust i C++
\chapter{Wnioski oraz rekomendacje}
Przeprowadzone badanie ujawniło fundamentalne ograniczenie narzędzia hwloc-ps na platformie macOS, szczególnie w architekturze Apple Silicon, wynikające z celowych restrykcji systemowych w jądrze XNU. Jak wykazano w \cite{HWLOC555}, brak implementacji interfejsów sched\_setaffinity()/sched\_getaffinity() uniemożliwia odczyt i kontrolę przypisań procesów do rdzeni (process-to-core binding), co stanowi istotną barierę metodologiczną w porównawczych badaniach wydajnościowych między architekturami ARM (M1) i x86\_64. W odróżnieniu od pełnej funkcjonalności hwloc-ps w systemie Linux \cite{hwlocHardwareLocality}, gdzie narzędzie precyzyjnie raportuje przypisania wątków, na macOS możliwe jest jedynie wykrywanie topologii sprzętowej przez lstopo – przy użyciu mechanizmów sysctl. Ograniczenie to, uniemożliwiło bezpośrednią weryfikację wpływu przypisań wątków (thread pinning) na wydajność implementacji współbieżnych w językach Rust/C++.

The option of developing new computer languages may be the clean- est and most efficient way to provide support for parallel processing. However, practical issues make the wide acceptance of a new computer language close to impossible. Nobody likes to rewrite old code to new lan- guages. It is difficult to justify such effort in most cases. Also, educating and convincing a large enough group of developers to make a new lan- guage gain critical mass is an extremely difficult task.