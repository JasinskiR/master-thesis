%1
@book{mitzenmacher2017probability,
  title={Probability and Computing: Randomization and Probabilistic Techniques in Algorithms and Data Analysis},
  author={Mitzenmacher, M. and Upfal, E.},
  isbn={9781108107990},
  url={https://books.google.pl/books?id=5tUoDwAAQBAJ},
  year={2017},
  publisher={Cambridge University Press}
}
%2
@book{TheRustProgrammingLanguage,
  author = {Klabnik, Steve and Nichols, Carol},
  title = {The Rust Programming Language},
  year = {2018},
  isbn = {1593278284},
  publisher = {No Starch Press},
  address = {USA}
}
%3
@book{HandsOnConcurrencywithRust,
  title={Hands-On Concurrency with Rust: Confidently build memory-safe, parallel, and efficient software in Rust},
  author={Troutwine, B.L.},
  isbn={9781788478359},
  url={https://books.google.pl/books?id=FHxeDwAAQBAJ},
  year={2018},
  publisher={Packt Publishing}
}
%4
@book{RustAtomicsAndLocks,
  title={Rust Atomics and Locks: Low-Level Concurrency in Practice},
  author={Bos, M.},
  isbn={9781098119409},
  url={https://books.google.pl/books?id=jPqhEAAAQBAJ},
  year={2022},
  publisher={O'Reilly Media}
}
%5
@book{MasteringConcurrencyAndParallelProgramming,
  title={Mastering Concurrency And Parallel Programming: Atain Advanced Techniques and Best Practices for Crafting Robust, Manitainable, and High-Performance Concurrent Code in C++},
  author={Matthew Galvin},
  isbn={9798326727572},
  url={},
  year={2024},
  publisher={}
}
%6
@misc{ParallelProgramminginC++withOpenMP,
  author = {Vũ Quang Trọng (vuquangtrong@gmail.com)},
  title = {{I}ntroduction to {P}arallel {P}rogramming in {C}++ with {O}pen{M}{P} - {S}tephan {O}\&apos;{B}rien --- physics.mcgill.ca},
  howpublished = {\url{https://www.physics.mcgill.ca/~obriens/Tutorials/parallel-cpp/}},
  year = {},
  note = {[Dostęp 23-12-2024]},
}
%7
@book{ConcurrencyInAction,
  title={C++ Concurrency in Action},
  author={Williams, A.},
  isbn={9781638356356},
  url={https://books.google.pl/books?id=BzgzEAAAQBAJ},
  year={2019},
  publisher={Manning}
}
%8
@book{ProgramminInOpenMp,
  title={Parallel Programming in OpenMP},
  author={Chandra, R.},
  isbn={9781558606715},
  lccn={00043828},
  series={High performance computing},
  url={https://books.google.pl/books?id=18CmnqIhbhUC},
  year={2001},
  publisher={Elsevier Science}
}
%9
@misc{RapidInnovationMasteringRust,
	author = {Rapid Innovation},
	title = {{M}astering {R}ust {C}oncurrency \& {P}arallelism: {U}ltimate {G}uide 2024 --- rapidinnovation.io},
	howpublished = {\url{https://www.rapidinnovation.io/post/concurrent-and-parallel-programming-with-rust#2-basics-of-rust-for-concurrent-programming}},
	year = {},
	note = {[Dostęp 23-12-2024]},
}

@inproceedings{10.1145/3678232.3678258,
  author = {Chen, Tzu-Chun and Dezani-Ciancaglini, Mariangiola and Yoshida, Nobuko},
  title = {On the Preciseness of Subtyping in Session Types: 10 Years Later},
  year = {2024},
  isbn = {9798400709692},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3678232.3678258},
  doi = {10.1145/3678232.3678258},
  abstract = {The PPDP Most Influential Paper 10-Year Award for our work&nbsp;[11] was a delightful surprise. We subsequently reviewed the subsequent literature to see how our results have been utilised. This short note aims to capture crucial references without missing too many.},
  booktitle = {Proceedings of the 26th International Symposium on Principles and Practice of Declarative Programming},
  articleno = {2},
  numpages = {3},
  keywords = {π -calculus, Session types, Soundness and Completeness, Subtyping},
  location = {Milano, Italy},
  series = {PPDP '24}
}

@ARTICLE{ZamiennikWEmbedded,
	author = {Vandervelden, Thibaut and De Smet, Ruben and Deac, Diana and Steenhaut, Kris and Braeken, An},
	title = {Overview of Embedded Rust Operating Systems and Frameworks},
	year = {2024},
	journal = {Sensors},
	volume = {24},
	number = {17},
	doi = {10.3390/s24175818},
	url = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85203869090&doi=10.3390%2fs24175818&partnerID=40&md5=33ec1f280a710122d80b3020dd5fe952},
	type = {Article},
	publication_stage = {Final},
	source = {Scopus},
	note = {Cited by: 0; All Open Access, Gold Open Access}
}

@ARTICLE{GPUSystemComapre,
	author = {Köpcke, Bastian and Gorlatch, Sergei and Steuwer, Michel},
	title = {Descend: A safe gpu systems programming language},
	year = {2024},
	journal = {Proceedings of the ACM on Programming Languages},
	volume = {8},
	doi = {10.1145/3656411},
	url = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85196889256&doi=10.1145%2f3656411&partnerID=40&md5=7e62e394af867f152334535cb3daa309},
	type = {Article},
	publication_stage = {Final},
	source = {Scopus},
	note = {Cited by: 0; All Open Access, Gold Open Access, Green Open Access}
}

@inproceedings{WhenIsParallelismFearlessandZeroCostwithRust?,
  author = {Abdi, Javad and Posluns, Gilead and Zhang, Guozheng and Wang, Boxuan and Jeffrey, Mark C.},
  title = {When Is Parallelism Fearless and Zero-Cost with Rust?},
  year = {2024},
  isbn = {9798400704161},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3626183.3659966},
  doi = {10.1145/3626183.3659966},
  abstract = {The Rust programming language is lauded for enabling fearless concurrency with zero cost: detecting concurrency errors at compile time. Given the enduring difficulty of parallel programming in other languages, this implied panacea warrants analysis. In particular, the efficacy of Rust across types of parallelism remains unexplored. Is parallel programming always devoid of fear with Rust? We answer this question through a case study, porting 14 benchmarks with abundant regular and irregular parallelism from C++ to Rust and reporting our experience and observations. We find that Rust, with the Rayon library, indeed delivers fearlessness for program phases comprising only regular parallelism, e.g., prefix-sum. However, for applications with any irregular parallelism, the programmer must choose between unsafe code or high-overhead dynamic checks with errors that manifest at run time, leaving the arduous task of parallel programming as scary with Rust as with its predecessors.},
  booktitle = {Proceedings of the 36th ACM Symposium on Parallelism in Algorithms and Architectures},
  pages = {27–40},
  numpages = {14},
  keywords = {fearless concurrency, irregular parallelism, regular parallelism, rust, zero-cost abstraction},
  location = {Nantes, France},
  series = {SPAA '24}
}

@misc{RustDifferences,
	author = {Yegor Gusakov},
	title = {{C}++ {V}s. {R}ust: 6 {K}ey {D}ifferences — {Q}{I}{T} --- qit.software},
	howpublished = {\url{https://qit.software/c-vs-rust-6-key-differences/}},
	year = {},
	note = {[Dostęp 28-01-2025]},
}

@misc{RustDifferences1,
	author = {Zoltan Fehervari},
	title = {{R}ust vs {C}++: {M}odern {D}evelopers' {D}ilemma --- bluebirdinternational.com},
	howpublished = {\url{https://bluebirdinternational.com/rust-vs-c/}},
	year = {},
	note = {[Dostęp 28-01-2025]},
}

@inproceedings{RustSafety1,
  title={Benefits and drawbacks of adopting a secure programming language: Rust as a case study},
  author={Fulton, Kelsey R and Chan, Anna and Votipka, Daniel and Hicks, Michael and Mazurek, Michelle L},
  booktitle={Seventeenth Symposium on Usable Privacy and Security (SOUPS 2021)},
  pages={597--616},
  year={2021}
}

@inproceedings{RustSafety2,
  title={Towards rust for critical systems},
  author={Pinho, Andr{\'e} and Couto, Luis and Oliveira, Jos{\'e}},
  booktitle={2019 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)},
  pages={19--24},
  year={2019},
  organization={IEEE}
}

@article{RustSafety3,
  title={Safe systems programming in Rust},
  author={Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
  journal={Communications of the ACM},
  volume={64},
  number={4},
  pages={144--152},
  year={2021},
  publisher={ACM New York, NY, USA}
}

@article{UnsafeRust,
  title={How do programmers use unsafe rust?},
  author={Astrauskas, Vytautas and Matheja, Christoph and Poli, Federico and M{\"u}ller, Peter and Summers, Alexander J},
  journal={Proceedings of the ACM on Programming Languages},
  volume={4},
  number={OOPSLA},
  pages={1--27},
  year={2020},
  publisher={ACM New York, NY, USA}
}

@article{RustFC,
  title={Fearless concurrency? understanding concurrent programming safety in real-world rust software},
  author={Yu, Zeming and Song, Linhai and Zhang, Yiying},
  journal={arXiv preprint arXiv:1902.01906},
  year={2019}
}

@misc{RustPerformance1,
  title={Evaluating Memory Models for Graph-Like Data Structures in the Rust Programming Language: Performance and Usabiliy},
  author={Viitanen, Rasmus},
  year={2020}
}

@inproceedings{RustPerformance2,
  title={Exploring rust for unikernel development},
  author={Lankes, Stefan and Breitbart, Jens and Pickartz, Simon},
  booktitle={Proceedings of the 10th Workshop on Programming Languages and Operating Systems},
  pages={8--15},
  year={2019}
}

@inproceedings{RustPerformance3,
  title={Performance vs programming effort between rust and c on multicore architectures: Case study in n-body},
  author={Costanzo, Manuel and Rucci, Enzo and Naiouf, Marcelo and De Giusti, Armando},
  booktitle={2021 XLVII Latin American Computing Conference (CLEI)},
  pages={1--10},
  year={2021},
  organization={IEEE}
}

@article{RustPerformance4,
  title={Rust as a language for high performance GC implementation},
  author={Lin, Yi and Blackburn, Stephen M and Hosking, Antony L and Norrish, Michael},
  journal={ACM SIGPLAN Notices},
  volume={51},
  number={11},
  pages={89--98},
  year={2016},
  publisher={ACM New York, NY, USA}
}

@misc{parallelrustcppIntroductionComparing,
	author = {Matias Lindgren},
	title = {{I}ntroduction - {C}omparing parallel {R}ust and {C}++ --- parallel-rust-cpp.github.io},
	howpublished = {\url{https://parallel-rust-cpp.github.io}},
	year = {},
	note = {[Dostęp 28-01-2025]},
}

@ARTICLE{FastFlow,
	author = {Rinaldi, Luca and Torquati, Massimo and Danelutto, Marco},
	title = {Enforcing reference capability in FastFlow with rust},
	year = {2020},
	journal = {Advances in Parallel Computing},
	volume = {36},
	pages = {396 – 405},
	doi = {10.3233/APC200064},
	url = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85083066249&doi=10.3233%2fAPC200064&partnerID=40&md5=9d13800137f18a8c8a6cb1cf4f415689},
	type = {Conference paper},
	publication_stage = {Final},
	source = {Scopus},
	note = {Cited by: 0; All Open Access, Gold Open Access}
}

@book{rustPolishNames,
  title={Programming Rust},
  author={Blandy, J. and Orendorff, J. and Tindall, L.F.S.},
  isbn={9781492052548},
  url={https://books.google.pl/books?id=qFkzEAAAQBAJ},
  year={2021},
  publisher={O'Reilly Media}
}

@misc{SecurityInRust,
title={Rust Software Security: A Current State Assessment},
  author={Sible, Joe and Svoboda, David},
  month={Dec},
  year={2022},
  howpublished={Carnegie Mellon University, Software Engineering Institute's Insights (blog)},
  url={https://doi.org/10.58012/0px4-9n81},
  note={[Dostęp: 2025-Mar-12]}
}

@ARTICLE{MigratingCtoRustforMemorySafety,
author={Larsen, Per},
journal={ IEEE Security \& Privacy },
title={{ Migrating C to Rust for Memory Safety }},
year={2024},
volume={22},
number={04},
ISSN={1558-4046},
pages={22-29},
abstract={ The path for migrating C to Rust can be partially automated. This article discusses when to choose automation and when to migrate by hand and considers several paths to increase automation so more code can be migrated at constant cost. },
keywords={Codes;Safety;Program processors;Memory management;Resource management;Security;Costs;Computer languages;Automation;Quality assessment},
doi={10.1109/MSEC.2024.3385357},
url = {https://doi.ieeecomputersociety.org/10.1109/MSEC.2024.3385357},
publisher={IEEE Computer Society},
address={Los Alamitos, CA, USA},
month=jul}

@misc{Lesiński,
  url={https://kornel.ski/rust-c-speed}, journal={Speed of rust vs C},
  author={Lesiński, Kornel}
} 

@misc{bytebytegoEP108Design,
	author = {ByteByteGo},
	title = {{E}{P}108: {H}ow do we design a secure system? --- blog.bytebytego.com},
	howpublished = {\url{https://blog.bytebytego.com/p/ep108-how-do-we-design-a-secure-system?utm_campaign=post&utm_medium=web}},
	year = {},
	note = {[Dostęp 09-03-2025]},
}

@book{IntroductionToConcurrencyAndParallelism,
  title={Grokking Concurrency},
  author={Bobrov, K.},
  isbn={9781633439771},
  url={https://books.google.pl/books?id=pORwzwEACAAJ},
  year={2024},
  publisher={Manning}
}

@misc{Paluch,
	author = {Witold Paluszynski},
	title = {{S}ystemy {C}zasu {R}zeczywistego i {S}ieci {K}omputerowe - {W}itold {P}aluszynski --- kcir.pwr.edu.pl},
	howpublished = {\url{https://kcir.pwr.edu.pl/~witold/scrsk/#literatura}},
	year = {},
	note = {[Dostęp 10-03-2025]},
}

@book{ParallelProgramming,
  abstract = {Author Peter Pacheco uses a tutorial approach to show students how to develop effective parallel programs with MPI, Pthreads, and OpenMP. The first undergraduate text to directly address compiling and running parallel programs on the new multi-core and cluster architecture, An Introduction to Parallel Programming explains how to design, debug, and evaluate the performance of distributed and shared-memory programs. User-friendly exercises teach students how to compile, run and modify example programs.},
  added-at = {2016-02-09T12:34:47.000+0100},
  author = {Pacheco, Peter},
  biburl = {https://www.bibsonomy.org/bibtex/2a65d99e800419cc66da430c30751eaeb/ytyoun},
  interhash = {6eabc2a61afcf26e9afa398b3748ec19},
  intrahash = {a65d99e800419cc66da430c30751eaeb},
  isbn = {9780123742605 0123742609},
  keywords = {parallel programming textbook},
  publisher = {Morgan Kaufmann},
  refid = {668986119},
  timestamp = {2016-02-09T12:34:47.000+0100},
  title = {An Introduction to Parallel Programming},
  year = 2011
}

@misc{ZastosowanieWspolbieznosci,
	author = {Hostwinds Team},
	title = {{R}ust vs {C}++: {A} {Q}uick {G}uide for {D}evelopers | {H}ostwinds --- hostwinds.com},
	howpublished = {\url{https://www.hostwinds.com/blog/rust-vs-c-a-quick-guide-for-developers}},
	year = {},
	note = {[Dostęp 13-03-2025]},
}

@misc{ProsAndCons,
	author = {},
	title = {{S}afety: {A} comparaison between {R}ust, {C}++ and {G}o | {H}acker {N}ews --- news.ycombinator.com},
	howpublished = {\url{https://news.ycombinator.com/item?id=32285122}},
	year = {},
	note = {[Dostęp 13-03-2025]},
}

@book{CUDA,
title = {Professional CUDA C Programming},
year = {2014},
isbn = {1118739329},
publisher = {Wrox Press Ltd.},
address = {GBR},
edition = {1st},
}

@misc{wikipediaRustprogramming,
	author = {},
	title = {{R}ust (programming language) - {W}ikipedia --- en.wikipedia.org},
	howpublished = {\url{https://en.wikipedia.org/wiki/Rust_(programming_language)}},
	year = {},
	note = {[Dostęp 16-03-2025]},
}

@misc{wikipediaWikipedia,
	author = {},
	title = {{C}++ - {W}ikipedia --- en.wikipedia.org},
	howpublished = {\url{https://en.wikipedia.org/wiki/C%2B%2B}},
	year = {},
	note = {[Dostęp 16-03-2025]},
}


@Article{PPL1_1,
AUTHOR = {Yin, Xiaohua and Huang, Zhiqiu and Kan, Shuanglong and Shen, Guohua},
TITLE = {SafeMD: Ownership-Based Safe Memory Deallocation for C Programs},
JOURNAL = {Electronics},
VOLUME = {13},
YEAR = {2024},
NUMBER = {21},
ARTICLE-NUMBER = {4307},
URL = {https://www.mdpi.com/2079-9292/13/21/4307},
ISSN = {2079-9292},
ABSTRACT = {Rust is a relatively new programming language that aims to provide memory safety at compile time. It introduces a novel ownership system that enforces the automatic deallocation of unused resources without using a garbage collector. In light of Rust’s promise of safety, a natural question arises about the possible benefits of exploiting ownership to ensure the memory safety of C programs. In our previous work, we developed a formal ownership checker to verify whether a C program satisfies exclusive ownership constraints. In this paper, we further propose an ownership-based safe memory deallocation approach, named SafeMD, to fix memory leaks in the C programs that satisfy exclusive ownership defined in the prior formal ownership checker. Benefiting from the C programs satisfying exclusive ownership, SafeMD obviates alias and inter-procedural analysis. Also, the patches generated by SafeMD make the input C programs still satisfy exclusive ownership. Usually, a C program that satisfies the exclusive ownership constraints is safer than its normal version. Our evaluation shows that SafeMD is effective in fixing memory leaks of C programs that satisfy exclusive ownership.},
DOI = {10.3390/electronics13214307}
}

@CONFERENCE{PPL1_2,
	author = {Silva, Tiago and Bispo, João and Carvalho, Tiago},
	title = {Foundations for a Rust-Like Borrow Checker for C},
	year = {2024},
	journal = {Proceedings of the ACM SIGPLAN Conference on Languages, Compilers, and Tools for Embedded Systems (LCTES)},
	pages = {155 – 165},
	doi = {10.1145/3652032.3657579},
	url = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85197266852&doi=10.1145%2f3652032.3657579&partnerID=40&md5=3c8e90b1cd3bcb94f998ed506a3a3b83},
	type = {Conference paper},
	publication_stage = {Final},
	source = {Scopus},
	note = {Cited by: 0; All Open Access, Hybrid Gold Open Access}
}

@INPROCEEDINGS{FFTPerformance,
  author={Rooney, Michael P. and Matthews, Suzanne J.},
  booktitle={2023 57th Annual Conference on Information Sciences and Systems (CISS)}, 
  title={Evaluating FFT performance of the C and Rust Languages on Raspberry Pi platforms}, 
  year={2023},
  volume={},
  number={},
  pages={1-6},
  doi={10.1109/CISS56502.2023.10089631}} 

@unknown{LanguageComparison_1,
author = {Ali, Saqib and Qayyum, Sammar},
year = {2021},
month = {06},
pages = {},
title = {A Pragmatic Comparison of Four Different Programming Languages},
doi = {10.14293/S2199-1006.1.SOR-.PP5RV1O.v1}
}

@article{LanguageComparison_2,
author = {Alomari, Zakaria and Halimi, Oualid and Sivaprasad, Kaushik and Pandit, Chitrang},
year = {2015},
month = {04},
pages = {},
title = {Comparative Studies of Six Programming Languages}
}

@misc{LanguageComparison_3,
	author = {},
	title = { {C}omparing {P}rogramming {L}anguages  --- cs.ucf.edu},
	howpublished = {\url{https://www.cs.ucf.edu/~leavens/ComS541Fall98/hw-pages/comparing/}},
	year = {},
	note = {[Dostęp 16-03-2025]},
}

@misc{LanguageComparison_4,
	author = {},
	title = {{H}ow do you compare programming languages in a coding interview? --- linkedin.com},
	howpublished = {\url{https://www.linkedin.com/advice/1/how-do-you-compare-programming-languages-coding}},
	year = {},
	note = {[Dostęp 16-03-2025]},
}

%abstrakcje - jako conclusion
@article{ConcurrentSemanticComparison_1,
title = {Design of an empirical study for comparing the usability of concurrent programming languages},
journal = {Information and Software Technology},
volume = {55},
number = {7},
pages = {1304-1315},
year = {2013},
issn = {0950-5849},
doi = {https://doi.org/10.1016/j.infsof.2012.08.013},
url = {https://www.sciencedirect.com/science/article/pii/S0950584912001802},
author = {Sebastian Nanz and Faraz Torshizi and Michela Pedroni and Bertrand Meyer},
keywords = {Empirical study, Concurrency, Programming languages, Usability},
abstract = {Context: Developing concurrent software has long been recognized as a difficult and error-prone task. To support developers, a multitude of language proposals exist that promise to make concurrent programming easier. Empirical studies are needed to support the claim that a language is more usable than another. Objective: This paper presents the design of a study to compare concurrent programming languages with respect to comprehending and debugging existing programs and writing correct new programs. The design is applied to a comparison of two object-oriented languages for concurrency, multithreaded Java and SCOOP. Method: A critical challenge for such a study is avoiding the bias that might be introduced during the training phase and when interpreting participants’ solutions. We address these issues by the use of self-study material and an evaluation scheme that exposes any subjective decisions of the corrector, or eliminates them altogether. Results: The study template consisting of the experimental design and the structure of the self-study and evaluation material is demonstrated to work successfully in an academic setting. The concrete instantiation of the study template shows results in favor of SCOOP even though the study participants had previous training in writing multithreaded Java programs. Conclusion: It is concluded that the proposed template of a small but therefore easy-to-implement empirical study with a focus on core language constructs is helpful in characterizing the usability of concurrent programming paradigms. Applying the template to further languages could shed light on which approaches are promising and hence drive language research into the right direction.}
}
%Powyższa cytuje tą niżej, ale inne badnie przeprowadzili
@article{ConcurrentSemanticComparison_2,
author = {Nanz, Sebastian and Torshizi, Faraz and Pedroni, Michela and Meyer, Bertrand},
year = {2010},
month = {11},
pages = {},
title = {A Comparative Study of the Usability of Two Object-oriented Concurrent Programming Languages},
volume = {55},
journal = {Information and Software Technology},
doi = {10.1016/j.infsof.2012.08.013}
}

@misc{rainbow,
	author = {Remy DeWolf},
	title = {{I}ntroducing {R}ainbow: {C}ompare the {P}erformance of {D}ifferent {P}rogramming {L}anguages --- medium.com},
	howpublished = {\url{https://medium.com/better-programming/introducing-rainbow-compare-the-performance-of-different-programming-languages-f08a67453cd4 }},
	year = {},
	note = {[Dostęp 16-03-2025]},
}

@misc{rustgpuRust,
	author = {},
	title = {{R}ust {G}{P}{U} --- rust-gpu.github.io},
	howpublished = {\url{https://rust-gpu.github.io}},
	year = {},
	note = {[Dostęp 22-03-2025]},
}

@misc{docsVulkanoRust,
	author = {},
	title = {vulkano - {R}ust --- docs.rs},
	howpublished = {\url{https://docs.rs/vulkano/0.12.0/vulkano/}},
	year = {},
	note = {[Dostęp 22-03-2025]},
}

@misc{nvidiaCUDAToolkit,
	author = {},
	title = {{C}{U}{D}{A} {T}oolkit - {F}ree {T}ools and {T}raining --- developer.nvidia.com},
	howpublished = {\url{https://developer.nvidia.com/cuda-toolkit}},
	year = {},
	note = {[Dostęp 22-03-2025]},
}

@misc{wgpuWgpuPortable,
	author = {},
	title = {wgpu: portable graphics library for {R}ust --- wgpu.rs},
	howpublished = {\url{https://wgpu.rs}},
	year = {},
	note = {[Dostęp 22-03-2025]},
}

@misc{heyman2020comparison,
  title={A comparison of performance \& implementation complexity of multithreaded applications in rust, java and c++},
  author={Heyman, Hugo and Brandefelt, Love},
  year={2020}
}

@misc{martins2025npbrustnasparallelbenchmarks,
      title={NPB-Rust: NAS Parallel Benchmarks in Rust}, 
      author={Eduardo M. Martins and Leonardo G. Faé and Renato B. Hoffmann and Lucas S. Bianchessi and Dalvan Griebler},
      year={2025},
      eprint={2502.15536},
      archivePrefix={arXiv},
      primaryClass={cs.DC},
      url={https://arxiv.org/abs/2502.15536}, 
}

@INPROCEEDINGS{Besozzi,
  author={Besozzi, Valerio},
  booktitle={2024 32nd Euromicro International Conference on Parallel, Distributed and Network-Based Processing (PDP)}, 
  title={PPL: Structured Parallel Programming Meets Rust}, 
  year={2024},
  volume={},
  number={},
  pages={78-87},
  keywords={Schedules;Parallel programming;Image processing;Ecosystems;Benchmark testing;Libraries;Hardware;Structured parallel programming;parallel processing;programming;rust;skeletal programming},
  doi={10.1109/PDP62718.2024.00019}}

@misc{nasaParallelBenchmarks,
	author = {},
	title = {{N}{A}{S} {P}arallel {B}enchmarks --- nas.nasa.gov},
	howpublished = {\url{https://www.nas.nasa.gov/software/npb.html}},
	year = {},
	note = {[Accessed 17-04-2025]},
}
@article{CPPNPB,
title = {The NAS Parallel Benchmarks for evaluating C++ parallel programming frameworks on shared-memory architectures},
journal = {Future Generation Computer Systems},
volume = {125},
pages = {743-757},
year = {2021},
issn = {0167-739X},
doi = {https://doi.org/10.1016/j.future.2021.07.021},
url = {https://www.sciencedirect.com/science/article/pii/S0167739X21002831},
author = {Júnior Löff and Dalvan Griebler and Gabriele Mencagli and Gabriell Araujo and Massimo Torquati and Marco Danelutto and Luiz Gustavo Fernandes},
keywords = {NAS Parallel Benchmarks, Parallel programming, Multicore architectures, Performance evaluation},
abstract = {The NAS Parallel Benchmarks (NPB), originally implemented mostly in Fortran, is a consolidated suite containing several benchmarks extracted from Computational Fluid Dynamics (CFD) models. The benchmark suite has important characteristics such as intensive memory communications, complex data dependencies, different memory access patterns, and hardware components/sub-systems overload. Parallel programming APIs, libraries, and frameworks that are written in C++ as well as new optimizations and parallel processing techniques can benefit if NPB is made fully available in this programming language. In this paper we present NPB-CPP, a fully C++ translated version of NPB consisting of all the NPB kernels and pseudo-applications developed using OpenMP, Intel TBB, and FastFlow parallel frameworks for multicores. The design of NPB-CPP leverages the Structured Parallel Programming methodology (essentially based on parallel design patterns). We show the structure of each benchmark application in terms of composition of few patterns (notably Map and MapReduce constructs) provided by the selected C++ frameworks. The experimental evaluation shows the accuracy of NPB-CPP with respect to the original NPB source code. Furthermore, we carefully evaluate the parallel performance on three multi-core systems (Intel, IBM Power, and AMD) with different C++ compilers (gcc, icc, and clang) by discussing the performance differences in order to give to the researchers useful insights to choose the best parallel programming framework for a given type of problem.}
}

@misc{NPBRust,
  author       = {Gabriel Leite Bessa and Luan Mark Da Silva Borela and João A. Soares},
  title        = {NPB-Rust: NAS Parallel Benchmarks in Rust},
  year         = {2025},
  howpublished = {\url{https://github.com/glbessa/NPB-Rust}},
  note         = {Dostęp: 2025-05-18}
}

@misc{cpp26,
	author = {},
	title = {{E}xecution control library (since {C}++26) - cppreference.com --- en.cppreference.com},
	howpublished = {\url{https://en.cppreference.com/w/cpp/execution.html}},
	year = {},
	note = {[Dostęp 31-05-2025]},
}

@misc{HWLOC555,
    author = {},
    title = {{C}{P}{U} binding on {M}ac{O}{S} · {I}ssue {\#}555 · open-mpi/hwloc --- github.com},
    howpublished = {\url{https://github.com/open-mpi/hwloc/issues/555}},
    year = {},
    note = {[Dostęp 01-06-2025]},
}
@misc{hwlocHardwareLocality,
	author = {},
	title = {{H}ardware {L}ocality (hwloc): {H}ardware {L}ocality --- hwloc.readthedocs.io},
	howpublished = {\url{https://hwloc.readthedocs.io/en/stable/}},
	year = {},
	note = {[Dostęp 01-06-2025]},
}

@misc{ARMTBB,
      title={Reverse Engineering the Apple M1 Conditional Branch Predictor for Out-of-Place Spectre Mistraining}, 
      author={Adam Tuby and Adam Morrison},
      year={2025},
      eprint={2502.10719},
      archivePrefix={arXiv},
      primaryClass={cs.CR},
      url={https://arxiv.org/abs/2502.10719}, 
}

@mastersthesis{TBBARMCONCLUSIONS,
  author       = {Joshua Duke},
  title        = {Memory Forensics Comparison of Apple M1 and Intel Architecture Using Volatility Framework},
  school       = {Louisiana State University},
  year         = {2021},
  type         = {Master's thesis},
  url          = {https://repository.lsu.edu/gradschool_theses/5477}
}
