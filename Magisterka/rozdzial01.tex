\chapter[Wstęp]{Wstęp}
% \addcontentsline{toc}{chapter}{Wstęp}  % Add unnumbered chapter to the table of contents if needed
\section{Cel oraz zakres pracy}
% \addcontentsline{toc}{chapter}{Cel i zakres pracy}  % Add unnumbered chapter to the table of contents if needed
Celem niniejszej pracy jest przeprowadzenie pogłębionej analizy oraz wszechstronnego porównania mechanizmów programowania współbieżnego i równoległego w dwóch językach programowania: Rust i C++. Celem jest przedstawienie kluczowych różnic oraz podobieństw w podejściu do zarządzania wielowątkowością, analizując jednocześnie efektywność, bezpieczeństwo oraz wygodę stosowania narzędzi dostępnych w obu językach.

W ramach pracy szczególną uwagę poświęcono omówieniu wybranych bibliotek i frameworków, które wspierają tworzenie aplikacji wielowątkowych w Rust (np. Tokio, Rayon) i C++ (np. std::thread, OpenMP, TBB). Przeanalizowane zostaną mechanizmy bezpieczeństwa oraz zarządzania pamięcią i wątkami, które odgrywają kluczową rolę w zapewnieniu stabilności i~wydajności aplikacji współbieżnych i równoległych.

Dodatkowym celem jest przeprowadzenie analizy wydajności oraz efektywności implementacji aplikacji wielowątkowych, co pozwoli na ocenę szybkości działania i efektywnego zarządzania zasobami w obu językach. Badanie uwzględni również aspekty praktyczne, takie jak łatwość użycia narzędzi, dostępność wsparcia ze strony społeczności oraz dojrzałość ekosystemu każdego z języków.

Aby zilustrować wyniki teoretyczne w praktyce, przeprowadzona zostanie implementacja aplikacji współbieżnych i równoległych w obu językach, co umożliwi porównanie osiągniętych wyników wydajnościowych oraz analizę różnic w strukturze i stylu kodu. Efektem pracy będzie również identyfikacja scenariuszy, w których jeden z języków może przewyższać drugi pod względem wydajności, bezpieczeństwa, czy wygody stosowania, co pozwoli na sformułowanie rekomendacji dotyczących wyboru języka w zależności od specyficznych wymagań projektowych.
\section{Problem badawczy}
Wraz z rozwojem nowoczesnych technologii informatycznych i rosnącą złożonością systemów obliczeniowych, znaczenia nabierają paradygmaty programowania, które pozwalają na maksymalne wykorzystanie zasobów współczesnego sprzętu komputerowego — w szczególności architektur wielordzeniowych. Programowanie współbieżne i równoległe stanowią obecnie podstawę projektowania wydajnych i niezawodnych aplikacji w wielu obszarach, od systemów operacyjnych, aż po rozwiązania z zakresu sztucznej inteligencji czy gier komputerowych.

W kontekście tych wyzwań szczególnie interesujące staje się porównanie narzędzi, jakie oferują współczesne języki programowania. Niniejsza praca magisterska koncentruje się na analizie dwóch języków: Rust oraz C++, które - mimo odmiennej filozofii projektowej - są powszechnie wykorzystywane w systemach wymagających wysokiej wydajności. Rust, jako stosunkowo młody język, zdobywa coraz większą popularność ze względu na nowatorskie podejście do bezpieczeństwa pamięci i współbieżności, opierające się na systemie własności \eng{ownership} oraz sprawdzaniu poprawności kodu na etapie kompilacji. Dzięki temu minimalizuje ryzyko wycieków pamięci, błędów synchronizacji czy wyścigów danych. Z kolei C++ - język dojrzały, o długiej historii i ugruntowanej pozycji w przemyśle - oferuje szeroki wachlarz dojrzałych bibliotek równoległych (OpenMP, Intel TBB), jednak często kosztem większego ryzyka błędów programistycznych i bardziej złożonego zarządzania pamięcią.

Przegląd literatury ujawnił istotne luki badawcze w aktualnym stanie wiedzy. Po pierwsze, większość dotychczasowych badań porównawczych ograniczała się do klasycznych architektur x86\_64, pomijając wpływ nowoczesnych architektur ARM64 na wydajność mechanizmów programowania współbieżnego i równoległego. Po drugie, brakuje systematycznych analiz wykorzystujących uznane zestawy benchmarkowe, takie jak NAS Parallel Benchmarks, do porównania implementacji w języku Rust z dojrzałymi rozwiązaniami C++.

W związku z powyższym, głównym problemem badawczym pracy są następujące pytania:
\begin{quote}
    \item \textbf{PB1}: 
    \emph{Jakie są różnice w wydajności i charakterystykach skalowania mechanizmów programowania równoległego między językami Rust (Rayon) a C++ (OpenMP, Intel TBB) na architekturach ARM64 i x86\_64, mierzone przy użyciu standardowych benchmarków NAS Parallel Benchmarks (CG, EP, IS)?}
    \item \textbf{PB2}:
    \emph{W jaki sposób wybór konkretnego języka i biblioteki wpływa na wydajność aplikacji współbieżnych pod względem przepustowości, zużycia pamięci oraz stabilności działania w różnych środowiskach kompilacji?}
    \item \textbf{PB3}:
    \emph{Jaki jest rzeczywisty narzut wydajnościowy związany z modelem bezpieczeństwa pamięci w języku Rust w porównaniu z mechanizmami zarządzania zasobami dostępnymi w C++, i czy różnice te są zależne od architektury sprzętowej?}
\end{quote}
Odpowiedź na te pytania zostanie udzielona poprzez systematyczne eksperymentalne porównanie konkretnych implementacji w obu językach, z wykorzystaniem standardowych metodologii pomiarowych oraz analizy statystycznej wyników uzyskanych na dwóch reprezentatywnych architekturach sprzętowych. Badania obejmą zarówno benchmarki obliczeniowe wysokiej wydajności, jak i praktyczne aplikacje reprezentujące typowe scenariusze współbieżności, co pozwoli na sformułowanie rekomendacji dotyczących wyboru odpowiednich narzędzi w zależności od specyfiki projektu i środowiska docelowego.

%%Układ dokumentu - Układ tego dokumentu przedstawia się następująco:
\section{Struktura pracy}
Niniejsza praca została zorganizowana w sposób umożliwiający systematyczne przedstawienie zagadnienia oraz przeprowadzenie kompleksowej analizy porównawczej mechanizmów programowania współbieżnego i równoległego w językach Rust i C++. Rozdział pierwszy przedstawia cel oraz zakres pracy, definiuje główne problemy badawcze i określa metodologię badań. Rozdział drugi wprowadza czytelnika w podstawy programowania współbieżnego i równoległego, omawiając kluczowe różnice między tymi paradygmatami oraz ich zastosowania w kontekście współczesnych systemów wielordzeniowych. Trzeci rozdział zawiera przegląd literatury przedmiotu, analizując dotychczasowe badania porównawcze języków programowania w kontekście mechanizmów wielowątkowości oraz identyfikując luki badawcze, które niniejsza praca ma wypełnić.
Rozdziały czwarty i piąty skupiają się na teoretycznych aspektach mechanizmów programowania współbieżnego i równoległego w analizowanych językach, omawiając dostępne biblioteki, frameworki oraz narzędzia zarządzania wątkami i pamięcią. Rozdział szósty przedstawia metodologię badań oraz procedury pomiarowe wykorzystane w eksperymentach, w tym opis środowiska sprzętowo-programowego, konfiguracji kompilatorów oraz protokołu eksperymentalnego dla benchmarków NPB i aplikacji testowych. Rozdział siódmy zawiera opis i implementację benchmarków NPB (Conjugate Gradient, Embarrassingly Parallel, Integer Sort) dla programowania równoległego oraz aplikacji testowych (producent-konsument, echo-serwer) dla programowania współbieżnego w językach Rust i C++. Rozdział ósmy prezentuje wyniki eksperymentów oraz ich szczegółową analizę, koncentrując się na porównaniu wydajności, wzorcach skalowania oraz wykorzystaniu zasobów systemowych przez implementacje na architekturach ARM64 i x86\_64. Rozdział dziewiąty prezentuje wnioski oraz rekomendacje dotyczące praktycznego zastosowania języków Rust i C++ w projektach wymagających wysokiej wydajności i bezpieczeństwa współbieżnego, identyfikując scenariusze optymalnego wykorzystania każdego z języków. Pracę zamyka rozdział dziesiąty, który podsumowuje najważniejsze osiągnięcia badawcze oraz wskazuje możliwe kierunki dalszych analiz i rozwijania zaproponowanych rozwiązań. Na samym końcu pracy znajduje się spis wykorzystanych rysunków, tabel, algorytmów oraz literatura.
\newpage
\section{Słownik wybranych pojęć}

\begin{itemize}
    \item \textbf{licznik Redis} - to mechanizm wykorzystujący bazę danych Redis do przechowywania i aktualizowania liczników w czasie rzeczywistym. Redis, jako szybka baza typu klucz-wartość, pozwala na błyskawiczne operacje inkrementacji i dekrementacji wartości przypisanej do danego klucza.

    \item \textbf{LLVM} - \eng{Low Level Virtual Machine} - to zestaw narzędzi i bibliotek do budowania kompilatorów, który umożliwia generowanie, analizę i optymalizację kodu (zarówno w czasie kompilacji, jak i wykonania). LLVM nie jest maszyną wirtualną w tradycyjnym sensie, ale raczej infrastrukturą kompilatora, która operuje na pośrednim języku reprezentacji (LLVM IR), z którego może generować kod maszynowy dla różnych architektur.

    \item \textbf{nieustraszona współbieżność} - \eng{fearless concurrency} - to podejście do programowania współbieżnego, które eliminuje problemy związane z bezpieczeństwem pamięci i synchronizacją wątków. W Rust osiągnięto to dzięki systemowi własności, który zapewnia, że dane mogą być modyfikowane tylko przez jeden wątek naraz, eliminując ryzyko wyścigów danych i błędów synchronizacji.

    \item \textbf{odwołania do nieobecnych stron} - \eng{page fault} - zdarzenie w systemie operacyjnym, które występuje, gdy program próbuje uzyskać dostęp do strony pamięci, która nie znajduje się obecnie w pamięci RAM. Może to skutkować koniecznością załadowania tej strony z dysku (np. z pliku wymiany), co wpływa na wydajność programu.

    \item \textbf{zwolnienie stron pamięci} - \eng{page reclaims} - operacje systemowe polegające na odzyskiwaniu już załadowanych, ale nieaktywnych stron pamięci, aby umożliwić ich ponowne wykorzystanie przez inne procesy. Pomaga to zoptymalizować wykorzystanie pamięci fizycznej bez konieczności natychmiastowego odwoływania się do pamięci wirtualnej.

    \item \textbf{pożyczanie} \eng{borrow} - również występujący pod inną nazwą jako przenoszenie własności \cite{rustPolishNames}, jest to mechanizm pozwalający na używanie wartości bez przejmowania jej na własność. Dzięki temu możemy przekazywać dane do funkcji lub między częściami programu bez ich kopiowania czy przenoszenia.

    \item \textbf{proces} - to instancja programu, która jest wykonywana w systemie operacyjnym. Procesy są izolowane od siebie i mają własne zasoby, takie jak pamięć i przestrzeń adresowa.

    \item \textbf{programowanie równoległe} - to sposób wykonywania wielu zadań jednocześnie, co zwiększa wydajność programu. W odróżnieniu od programowania współbieżnego, programowanie równoległe polega na wykonywaniu zadań w tym samym czasie, a nie przeplataniu ich w czasie.

    \item \textbf{programowanie współbieżne} - technika programistyczna polegająca na jednoczesnym wykonywaniu wielu zadań lub ich przeplataniu w czasie, mająca na celu zwiększenie efektywności działania programu. Współbieżność może być realizowana z wykorzystaniem wielu wątków, procesów bądź mechanizmów programowania asynchronicznego, które wewnętrznie mogą operować na wątkach lub innych zasobach udostępnianych przez system operacyjny.

    \item \textbf{SIMD} - \eng{Single Instruction, Multiple Data} - pojedyncza instrukcja wykonywana na wielu danych jednocześnie. Jest to technika optymalizacji wydajności obliczeń, która wykorzystuje jednostki wektorowe dostępne w nowoczesnych procesorach.

    \item \textbf{wątek} - część programu wykonywana współbieżnie w obrębie jednego procesu - w jednym procesie może istnieć wiele wątków. Główna różnica między procesem a wątkiem polega na tym, że wszystkie wątki należące do tego samego procesu współdzielą przestrzeń adresową oraz inne zasoby systemowe, takie jak listy otwartych plików czy gniazda sieciowe. Natomiast każdy proces dysponuje własnym, odrębnym zestawem zasobów.

    \item \textbf{własność} \eng{ownership} - system zarządzania pamięcią, który eliminuje konieczność używania automatycznego odśmiecania, jednocześnie zapobiegając błędom takim jak użycie po zwolnieniu czy podwójne zwolnienie.

    \item \textbf{wyścigi danych} \eng{race conditions} - to sytuacja, w której dwa lub więcej wątków lub procesów próbuje modyfikować wspólną zmienną w tym samym czasie, co prowadzi do nieprzewidywalnych wyników.
\end{itemize}

