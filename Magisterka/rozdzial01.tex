\chapter[Wstęp]{Wstęp}
% \addcontentsline{toc}{chapter}{Wstęp}  % Add unnumbered chapter to the table of contents if needed
\section{Cel oraz zakres pracy}
% \addcontentsline{toc}{chapter}{Cel i zakres pracy}  % Add unnumbered chapter to the table of contents if needed
Celem niniejszej pracy jest przeprowadzenie pogłębionej analizy oraz wszechstronnego porównania mechanizmów programowania współbieżnego i równoległego w dwóch językach programowania: Rust i C++. Celem jest przedstawienie kluczowych różnic oraz podobieństw w~podejściu do zarządzania wielowątkowością, analizując jednocześnie efektywność, bezpieczeństwo oraz wygodę stosowania narzędzi dostępnych w obu językach.

W ramach pracy szczególną uwagę poświęcono omówieniu wybranych bibliotek i frameworków, które wspierają tworzenie aplikacji wielowątkowych w Rust (np. Tokio, Rayon) i C++ (np. std::thread, OpenMP, TBB). Przeanalizowane zostaną mechanizmy bezpieczeństwa oraz zarządzania pamięcią i wątkami, które odgrywają kluczową rolę w zapewnieniu stabilności i~wydajności aplikacji współbieżnych i równoległych.

Dodatkowym celem jest przeprowadzenie analizy wydajności oraz efektywności implementacji aplikacji wielowątkowych, co pozwoli na ocenę szybkości działania i efektywnego zarządzania zasobami w obu językach. Badanie uwzględni również aspekty praktyczne, takie jak łatwość użycia narzędzi, dostępność wsparcia ze strony społeczności oraz dojrzałość ekosystemu każdego z języków.

Aby zilustrować wyniki teoretyczne w praktyce, przeprowadzona zostanie implementacja aplikacji współbieżnych i równoległych w obu językach, co umożliwi porównanie osiągniętych wyników wydajnościowych oraz analizę różnic w strukturze i stylu kodu. Efektem pracy będzie również identyfikacja scenariuszy, w których jeden z języków może przewyższać drugi pod względem wydajności, bezpieczeństwa, czy wygody stosowania, co pozwoli na sformułowanie rekomendacji dotyczących wyboru języka w zależności od specyficznych wymagań projektowych.
\section{Problem badawczy}
Wraz z rozwojem nowoczesnych technologii informatycznych i rosnącą złożonością systemów obliczeniowych, znaczenia nabierają paradygmaty programowania, które pozwalają na maksymalne wykorzystanie zasobów współczesnego sprzętu komputerowego — w szczególności architektur wielordzeniowych \cite{10876950,Sesay2024Parallelism}. Programowanie współbieżne i równoległe stanowią obecnie podstawę projektowania wydajnych i niezawodnych aplikacji w wielu obszarach, od systemów operacyjnych, aż po rozwiązania z zakresu sztucznej inteligencji czy gier komputerowych.

W kontekście tych wyzwań szczególnie interesujące staje się porównanie narzędzi, jakie oferują współczesne języki programowania. Niniejsza praca magisterska koncentruje się na analizie dwóch języków: Rust oraz C++, które - mimo odmiennej filozofii projektowej - są powszechnie wykorzystywane w systemach wymagających wysokiej wydajności \cite{Hazarika2025RustVsCpp}. Rust, jako stosunkowo młody język, zdobywa coraz większą popularność ze względu na nowatorskie podejście do bezpieczeństwa pamięci i współbieżności, opierające się na systemie własności \eng{ownership} oraz sprawdzaniu poprawności kodu na etapie kompilacji, co potwierdzają zarówno badania naukowe, jak i praktyczne analizy \cite{Saligrama2019RustConcurrency,RustFC}. Dzięki temu minimalizuje ryzyko wycieków pamięci, błędów synchronizacji czy wyścigów danych. Z kolei C++ - język dojrzały, o długiej historii i~ugruntowanej pozycji w przemyśle - oferuje szeroki wachlarz dojrzałych bibliotek równoległych (OpenMP, Intel TBB), jednak często kosztem większego ryzyka błędów programistycznych i bardziej złożonego zarządzania pamięcią.

Przegląd literatury pokazuje, że większość dotychczasowych badań porównawczych koncentrowała się na klasycznych architekturach x86\_64, co skutkuje ograniczoną wiedzą na temat wpływu nowoczesnych architektur ARM64 na wydajność mechanizmów programowania współbieżnego i~równoległego. Choć pojawiają się już prace dotyczące tego zagadnienia, wciąż brakuje szeroko zakrojonych, systematycznych analiz obejmujących różne architektury sprzętowe i~zestawy benchmarkowe.

W kwestii porównania implementacji w języku Rust z dojrzałymi rozwiązaniami C++ przy użyciu uznanych zestawów benchmarkowych, takich jak NAS Parallel Benchmarks, literatura naukowa jest wciąż uboga. W ostatnim czasie pojawiły się jednak pierwsze publikacje, które próbują wypełnić tę lukę - przykładem jest praca \cite{martins2025npbrustnasparallelbenchmarks}, gdzie autorzy analizują wydajność Rust w~kontekście benchmarków równoległych, jednak nie obejmuje ona kompleksowego porównania z rozwiązaniami C++ na różnych platformach sprzętowych.

W efekcie, choć pojawiają się już pojedyncze próby porównania Rust i C++ w kontekście benchmarków równoległych, wciąż brakuje systematycznych, szeroko zakrojonych badań, które uwzględniałyby zarówno różne architektury (w tym ARM64), jak i różne zestawy benchmarków, a także zapewniałyby porównanie wydajności i niezawodności obu języków w praktycznych zastosowaniach.

W związku z powyższym, głównym problemem badawczym pracy są następujące pytania:
\begin{quote}
    \item \textbf{PB1}: 
    \emph{Jakie są różnice w wydajności i charakterystykach skalowania mechanizmów programowania równoległego między językami Rust (Rayon) a C++ (OpenMP, Intel TBB) na architekturach ARM64 i x86\_64, mierzone przy użyciu standardowych benchmarków NAS Parallel Benchmarks (CG, EP, IS)?}
    \item \textbf{PB2}:
    \emph{W jaki sposób wybór konkretnego języka i biblioteki wpływa na wydajność aplikacji współbieżnych pod względem przepustowości, zużycia pamięci oraz stabilności działania w~różnych środowiskach kompilacji?}
    \item \textbf{PB3}:
    \emph{Jaki jest rzeczywisty narzut wydajnościowy związany z modelem bezpieczeństwa pamięci w języku Rust w porównaniu z mechanizmami zarządzania zasobami dostępnymi w C++, i czy różnice te są zależne od architektury sprzętowej?}
\end{quote}
Odpowiedź na te pytania zostanie udzielona poprzez systematyczne eksperymentalne porównanie konkretnych implementacji w obu językach, z wykorzystaniem standardowych metodologii pomiarowych oraz analizy statystycznej wyników uzyskanych na dwóch reprezentatywnych architekturach sprzętowych. Badania obejmą zarówno benchmarki obliczeniowe wysokiej wydajności, jak i praktyczne aplikacje reprezentujące typowe scenariusze współbieżności, co pozwoli na sformułowanie rekomendacji dotyczących wyboru odpowiednich narzędzi w zależności od specyfiki projektu i środowiska docelowego.

Wybór tematu pracy został dodatkowo umotywowany aktualnymi inicjatywami w zakresie bezpieczeństwa cybernetycznego oraz osobistymi doświadczeniami zawodowymi autora. W grudniu 2023 roku Agencja Bezpieczeństwa Cybernetycznego i Infrastruktury (CISA), we współpracy z Agencją Bezpieczeństwa Narodowego (NSA), FBI oraz międzynarodowymi organami ds. cyberbezpieczeństwa z Australii, Kanady, Nowej Zelandii i Wielkiej Brytanii, opublikowała wspólny przewodnik "The Case for Memory Safe Roadmaps" w ramach kampanii "Secure by Design" \cite{DoD2023MemorySafe}. Dokument ten zdecydowanie zachęca kierownictwo producentów oprogramowania do priorytetowego traktowania języków programowania bezpiecznych pod względem pamięci, tworzenia i publikowania map drogowych bezpieczeństwa pamięci oraz wdrażania zmian w celu wyeliminowania tej klasy podatności.

Agencje te podkreślają, że błędy bezpieczeństwa pamięci stanowią najczęstszy typ ujawnianych podatności oprogramowania, przy czym Microsoft potwierdził, że około 70\% jego błędów (CVE) to podatności związane z bezpieczeństwem pamięci, a Google poświadczył podobną cyfrę dla projektu Chromium. W tym kontekście agencje zalecają organizacjom odejście od C/C++, ponieważ nawet przy szkoleniach w zakresie bezpieczeństwa (i ciągłych wysiłkach na rzecz wzmocnienia kodu C/C++), programiści nadal popełniają błędy.

Dodatkowo, doświadczenia zawodowe autora w obszarze programowania równoległego wskazują na praktyczną potrzebę obiektywnej oceny narzędzi dostępnych w obu językach. W~środowisku przemysłowym coraz częściej pojawia się pytanie o zasadność migracji z dojrzałych rozwiązań C++ w kierunku nowszych technologii oferowanych przez Rust, szczególnie w kontekście aplikacji krytycznych pod względem wydajności i bezpieczeństwa.

%%Układ dokumentu - Układ tego dokumentu przedstawia się następująco:
\section{Struktura pracy}
Niniejsza praca została zorganizowana w sposób umożliwiający systematyczne przedstawienie zagadnienia oraz przeprowadzenie kompleksowej analizy porównawczej mechanizmów programowania współbieżnego i równoległego w językach Rust i C++.
Rozdział pierwszy przedstawia cel oraz zakres pracy, definiuje główne problemy badawcze i określa metodologię badań. Rozdział drugi wprowadza czytelnika w podstawy programowania współbieżnego i równoległego, omawiając kluczowe różnice między tymi paradygmatami oraz ich zastosowania w kontekście współczesnych systemów wielordzeniowych. Trzeci rozdział zawiera przegląd literatury przedmiotu, analizując dotychczasowe badania porównawcze języków programowania w kontekście mechanizmów wielowątkowości oraz identyfikując luki badawcze, które niniejsza praca ma wypełnić.
Rozdziały czwarty i piąty skupiają się na teoretycznych aspektach mechanizmów programowania współbieżnego i równoległego w analizowanych językach, omawiając dostępne biblioteki, frameworki oraz narzędzia zarządzania wątkami i pamięcią. Rozdział szósty przedstawia metodologię badań oraz procedury pomiarowe wykorzystane w eksperymentach, w tym opis środowiska sprzętowo-programowego, konfiguracji kompilatorów oraz protokołu eksperymentalnego dla benchmarków NPB i aplikacji testowych. Rozdział siódmy zawiera opis i~implementację benchmarków NPB (Conjugate Gradient, Embarrassingly Parallel, Integer Sort) dla programowania równoległego w językach Rust i C++. Rozdział ósmy przedstawia szczegółowy opis implementacji aplikacji testowych dla programowania współbieżnego (producent-konsument, echo-serwer), koncentrując się na specyfice programistycznej oraz architekturalnych rozwiązaniach zastosowanych w obu językach. Rozdział dziewiąty prezentuje wyniki eksperymentów dotyczących programowania równoległego oraz ich szczegółową analizę, koncentrując się na porównaniu wydajności benchmarków NPB, wzorcach skalowania oraz wykorzystaniu zasobów systemowych przez implementacje na architekturach ARM64 i x86\_64. Rozdział dziesiąty zawiera analizę wyników eksperymentów dotyczących programowania współbieżnego, przedstawiając porównanie wydajności aplikacji testowych oraz charakterystyk behawioralnych implementacji w obu językach.
Rozdział jedenasty prezentuje wnioski oraz rekomendacje dotyczące praktycznego zastosowania języków Rust i C++ w projektach wymagających wysokiej wydajności i bezpieczeństwa współbieżnego, identyfikując scenariusze optymalnego wykorzystania każdego z języków. Rozdział dwunasty podsumowuje najważniejsze osiągnięcia badawcze oraz wskazuje możliwe kierunki dalszych analiz i rozwijania zaproponowanych rozwiązań.
Na samym końcu pracy znajduje się literatura, spis wykorzystanych rysunków, tabel oraz listingów kodu.
% \newpage
\section{Słownik wybranych pojęć}

\begin{itemize}
    \item \textbf{licznik Redis} - to mechanizm wykorzystujący bazę danych Redis do przechowywania i aktualizowania liczników w czasie rzeczywistym. Redis, jako szybka baza typu klucz-wartość, pozwala na błyskawiczne operacje inkrementacji i dekrementacji wartości przypisanej do danego klucza.

    \item \textbf{LLVM} - \eng{Low Level Virtual Machine} - to zestaw narzędzi i bibliotek do budowania kompilatorów, który umożliwia generowanie, analizę i optymalizację kodu (zarówno w czasie kompilacji, jak i wykonania). LLVM nie jest maszyną wirtualną w tradycyjnym sensie, ale raczej infrastrukturą kompilatora, która operuje na pośrednim języku reprezentacji (LLVM IR), z którego może generować kod maszynowy dla różnych architektur.

    \item \textbf{nieustraszona współbieżność} - \eng{fearless concurrency} - to podejście do programowania współbieżnego, które eliminuje problemy związane z bezpieczeństwem pamięci i synchronizacją wątków. W Rust osiągnięto to dzięki systemowi własności, który zapewnia, że dane mogą być modyfikowane tylko przez jeden wątek naraz, eliminując ryzyko wyścigów danych i błędów synchronizacji.

    \item \textbf{odwołania do nieobecnych stron} - \eng{page fault} - zdarzenie w systemie operacyjnym, które występuje, gdy program próbuje uzyskać dostęp do strony pamięci, która nie znajduje się obecnie w pamięci RAM. Może to skutkować koniecznością załadowania tej strony z dysku (np. z pliku wymiany), co wpływa na wydajność programu.

    \item \textbf{zwolnienie stron pamięci} - \eng{page reclaims} - operacje systemowe polegające na odzyskiwaniu już załadowanych, ale nieaktywnych stron pamięci, aby umożliwić ich ponowne wykorzystanie przez inne procesy. Pomaga to zoptymalizować wykorzystanie pamięci fizycznej bez konieczności natychmiastowego odwoływania się do pamięci wirtualnej.

    \item \textbf{pożyczanie} \eng{borrow} - również występujący pod inną nazwą jako przenoszenie własności \cite{rustPolishNames}, jest to mechanizm pozwalający na używanie wartości bez przejmowania jej na własność. Dzięki temu możemy przekazywać dane do funkcji lub między częściami programu bez ich kopiowania czy przenoszenia.

    \item \textbf{proces} - to instancja programu, która jest wykonywana w systemie operacyjnym. Procesy są izolowane od siebie i mają własne zasoby, takie jak pamięć i przestrzeń adresowa.

    \item \textbf{programowanie równoległe} - to sposób wykonywania wielu zadań jednocześnie, co zwiększa wydajność programu. W odróżnieniu od programowania współbieżnego, programowanie równoległe polega na wykonywaniu zadań w tym samym czasie, a nie przeplataniu ich w~czasie.

    \item \textbf{programowanie współbieżne} - technika programistyczna polegająca na jednoczesnym wykonywaniu wielu zadań lub ich przeplataniu w czasie, mająca na celu zwiększenie efektywności działania programu. Współbieżność może być realizowana z wykorzystaniem wielu wątków, procesów bądź mechanizmów programowania asynchronicznego, które wewnętrznie mogą operować na wątkach lub innych zasobach udostępnianych przez system operacyjny.

    \item \textbf{SIMD} - \eng{Single Instruction, Multiple Data} - pojedyncza instrukcja wykonywana na wielu danych jednocześnie. Jest to technika optymalizacji wydajności obliczeń, która wykorzystuje jednostki wektorowe dostępne w nowoczesnych procesorach.

    \item \textbf{wątek} - część programu wykonywana współbieżnie w obrębie jednego procesu - w jednym procesie może istnieć wiele wątków. Główna różnica między procesem a wątkiem polega na tym, że wszystkie wątki należące do tego samego procesu współdzielą przestrzeń adresową oraz inne zasoby systemowe, takie jak listy otwartych plików czy gniazda sieciowe. Natomiast każdy proces dysponuje własnym, odrębnym zestawem zasobów.

    \item \textbf{własność} \eng{ownership} - system zarządzania pamięcią, który eliminuje konieczność używania automatycznego odśmiecania, jednocześnie zapobiegając błędom takim jak użycie po zwolnieniu czy podwójne zwolnienie.

    \item \textbf{wyścigi danych} \eng{race conditions} - to sytuacja, w której dwa lub więcej wątków lub procesów próbuje modyfikować wspólną zmienną w tym samym czasie, co prowadzi do nieprzewidywalnych wyników.
\end{itemize}

